{"version":3,"file":"remesh-logger.84358a20.js","sources":["../../packages/remesh/src/remesh.ts","../../packages/remesh/src/inspector.ts","../../packages/remesh/src/promise.ts","../../packages/remesh/src/store.ts","../../packages/remesh/src/index.ts","../../packages/remesh-react/src/remesh-react.tsx","../../packages/remesh-debugger-helper/src/remesh-debugger-helper.ts","../../packages/remesh-redux-devtools/src/remesh-redux-devtools.ts","../../packages/remesh-logger/src/remesh-logger.ts"],"sourcesContent":["import { concatMap, exhaustMap, mergeMap, Observable, switchMap } from 'rxjs'\n\nimport shallowEqual from 'shallowequal'\nimport { isPlainObject } from 'is-plain-object'\n\nimport { PromiseData } from './promise'\n\nexport type SerializableType =\n  | void\n  | number\n  | string\n  | boolean\n  | null\n  | undefined\n  | SerializableType[]\n  | { toJSON(): string }\n  | { [key: string]: SerializableType }\n\nexport type Undefined2Void<T> = undefined extends T ? Exclude<T, undefined> | void : T\n\nexport const undefined2Void = <T>(value: T): Undefined2Void<T> => {\n  return value as Undefined2Void<T>\n}\n\nexport type ExtractFirstArg<T extends (...args: any) => any> = Undefined2Void<Parameters<T>[0]>\n\nexport type ExtractSecondArg<T extends (...args: any) => any> = Undefined2Void<Parameters<T>[1]>\n\nexport type GetterInput<T extends SerializableType, U> = RemeshStateItem<T, U> | RemeshQueryPayload<T, U>\n\nexport type RemeshInjectedContext = {\n  get: <T extends SerializableType, U>(input: GetterInput<T, U>) => U\n  unwrap: <T extends SerializableType, U>(input: RemeshQueryPayload<T, Promise<U>>) => PromiseData<U>\n  fromEvent: <T, U>(Event: RemeshEvent<T, U>) => Observable<U>\n  fromQuery: <T extends SerializableType, U>(Query: RemeshQueryPayload<T, U>) => Observable<U>\n}\n\nexport type RemeshEventContext = {\n  get: RemeshInjectedContext['get']\n  unwrap: RemeshInjectedContext['unwrap']\n}\n\nexport type RemeshEvent<T, U = T> = {\n  type: 'RemeshEvent'\n  eventId: number\n  eventName: string\n  impl?: (context: RemeshEventContext, arg: T) => U\n  (arg: T): RemeshEventPayload<T, U>\n  owner: RemeshDomainPayload<any, any>\n  inspectable: boolean\n}\n\nexport type RemeshEventPayload<T, U = T> = {\n  type: 'RemeshEventPayload'\n  arg: T\n  Event: RemeshEvent<T, U>\n}\n\nexport type RemeshEventOptions<T, U> = {\n  name: string\n  inspectable?: boolean\n  impl: (context: RemeshEventContext, arg: T) => U\n}\n\nlet eventUid = 0\n\nexport function RemeshEvent<T extends RemeshEventOptions<any, any>>(\n  options: T,\n): RemeshEvent<ExtractSecondArg<T['impl']>, ReturnType<T['impl']>>\nexport function RemeshEvent<T = void>(options: { name: string }): RemeshEvent<T>\nexport function RemeshEvent(options: RemeshEventOptions<unknown, unknown> | { name: string }): RemeshEvent<any, any> {\n  const eventId = eventUid++\n\n  const Event = ((arg) => {\n    return {\n      type: 'RemeshEventPayload',\n      arg,\n      Event,\n    }\n  }) as RemeshEvent<any, any>\n\n  Event.type = 'RemeshEvent'\n  Event.eventId = eventId\n  Event.eventName = options.name\n  Event.owner = DefaultDomain()\n  Event.inspectable = 'inspectable' in options ? options.inspectable ?? true : true\n\n  if ('impl' in options) {\n    Event.impl = options.impl\n  }\n\n  return Event\n}\n\nexport type CompareFn<T> = (prev: T, curr: T) => boolean\n\nexport type RemeshStateChangedEventData<T> = {\n  previous: T\n  current: T\n}\n\nexport type RemeshState<T extends SerializableType, U> = {\n  type: 'RemeshState'\n  stateId: number\n  stateName: string\n  defer: boolean\n  impl: (arg: T) => U\n  (arg: T): RemeshStateItem<T, U>\n  owner: RemeshDomainPayload<any, any>\n  Query: RemeshQuery<T, U>\n  compare: CompareFn<U>\n  inspectable: boolean\n}\n\nexport type RemeshStateItem<T extends SerializableType, U> = {\n  type: 'RemeshStateItem'\n  arg: T\n  State: RemeshState<T, U>\n  new: (newState: U) => RemeshStatePayload<T, U>\n}\n\nexport type RemeshDefaultStateOptions<T> = {\n  name: RemeshState<void, T>['stateName']\n  default: T\n  inspectable?: boolean\n  compare?: RemeshState<void, T>['compare']\n}\n\nexport const RemeshDefaultState = <T>(options: RemeshDefaultStateOptions<T>): RemeshState<void, T> => {\n  return RemeshState({\n    name: options.name,\n    impl: () => options.default,\n    inspectable: options.inspectable,\n    compare: options.compare,\n  })\n}\n\nexport type RemeshDeferStateOptions<T extends SerializableType, U> = {\n  name: RemeshState<T, U>['stateName']\n  inspectable?: boolean\n  compare?: RemeshState<T, U>['compare']\n}\n\nexport const RemeshDeferState = <T extends SerializableType, U>(options: RemeshDeferStateOptions<T, U>) => {\n  return RemeshState({\n    name: options.name,\n    defer: true,\n    impl: (_arg: T): U => {\n      throw new Error(`RemeshDeferState: use ${options.name} before setting state`)\n    },\n    inspectable: options.inspectable,\n    compare: options.compare,\n  })\n}\n\nexport type RemeshStatePayload<T extends SerializableType, U> = {\n  type: 'RemeshStateSetterPayload'\n  stateItem: RemeshStateItem<T, U>\n  newState: U\n}\n\nexport type RemeshStateOptions<T extends SerializableType, U> = {\n  name: string\n  defer?: boolean\n  impl: (arg?: T) => U\n  inspectable?: boolean\n  compare?: CompareFn<U>\n}\n\nlet stateUid = 0\n\nexport const defaultCompare = <T>(prev: T, curr: T) => {\n  if (isPlainObject(prev) && isPlainObject(curr)) {\n    return shallowEqual(prev, curr)\n  }\n\n  if (Array.isArray(prev) && Array.isArray(curr)) {\n    return shallowEqual(prev, curr)\n  }\n\n  return prev === curr\n}\n\nexport const RemeshState = <T extends RemeshStateOptions<any, any>>(\n  options: T,\n): RemeshState<ExtractFirstArg<T['impl']>, ReturnType<T['impl']>> => {\n  const stateId = stateUid++\n\n  type StateArg = ExtractFirstArg<T['impl']>\n  type StateReturn = ReturnType<T['impl']>\n  type StateItem = RemeshStateItem<StateArg, StateReturn>\n\n  let cacheForNullary = null as StateItem | null\n\n  const State = ((arg) => {\n    if (arg === undefined && cacheForNullary) {\n      return cacheForNullary\n    }\n\n    const stateItem: StateItem = {\n      type: 'RemeshStateItem',\n      arg,\n      State,\n      new: (newState) => {\n        return {\n          type: 'RemeshStateSetterPayload',\n          stateItem,\n          newState,\n        }\n      },\n    }\n\n    if (arg === undefined) {\n      cacheForNullary = stateItem\n    }\n\n    return stateItem\n  }) as RemeshState<StateArg, StateReturn>\n\n  State.type = 'RemeshState'\n  State.stateId = stateId\n  State.stateName = options.name\n  State.impl = options.impl\n  State.compare = options.compare ?? defaultCompare\n  State.owner = DefaultDomain()\n  State.inspectable = options.inspectable ?? true\n  State.defer = options.defer ?? false\n\n  State.Query = RemeshQuery({\n    name: `${options.name}.Query`,\n    inspectable: false,\n    impl: ({ get }: RemeshQueryContext, arg: StateArg) => {\n      return get(State(arg))\n    },\n  })\n\n  return State\n}\n\nexport type RemeshSchedulerContext = {\n  get: RemeshInjectedContext['get']\n  unwrap: RemeshInjectedContext['unwrap']\n  fromEvent: RemeshInjectedContext['fromEvent']\n  fromQuery: RemeshInjectedContext['fromQuery']\n}\n\nexport type RemeshScheduler<U> = (context: RemeshSchedulerContext, input$: Observable<U>) => Observable<unknown>\n\nexport type RemeshQueryContext = {\n  get: RemeshInjectedContext['get']\n  unwrap: RemeshInjectedContext['unwrap']\n}\n\nexport type RemeshQueryPrepareOutput = RemeshStatePayload<any, any> | RemeshStatePayload<any, any>[] | null\n\nexport type RemeshQuery<T extends SerializableType, U> = {\n  type: 'RemeshQuery'\n  queryId: number\n  queryName: string\n  prepare?: (context: RemeshQueryContext, arg: T) => RemeshQueryPrepareOutput\n  impl: (context: RemeshQueryContext, arg: T) => U\n  (arg: T): RemeshQueryPayload<T, U>\n  owner: RemeshDomainPayload<any, any>\n  compare: CompareFn<U>\n  scheduler?: RemeshScheduler<U>\n  inspectable: boolean\n}\n\nexport type RemeshQueryPayload<T extends SerializableType, U> = {\n  type: 'RemeshQueryPayload'\n  Query: RemeshQuery<T, U>\n  arg: T\n}\n\nexport type RemeshQueryOptions<T extends SerializableType, U> = {\n  name: string\n  inspectable?: boolean\n  impl: (context: RemeshQueryContext, arg?: T) => U\n  prepare?: RemeshQuery<T, U>['prepare']\n  compare?: RemeshQuery<T, U>['compare']\n  scheduler?: RemeshQuery<T, U>['scheduler']\n}\n\nlet queryUid = 0\nexport const RemeshQuery = <T extends RemeshQueryOptions<any, any>>(\n  options: T,\n): RemeshQuery<ExtractSecondArg<T['impl']>, ReturnType<T['impl']>> => {\n  const queryId = queryUid++\n\n  /**\n   * optimize for nullary query\n   */\n  let cacheForNullary: RemeshQueryPayload<ExtractSecondArg<T['impl']>, ReturnType<T['impl']>> | null = null\n\n  const Query = ((arg) => {\n    if (arg === undefined && cacheForNullary) {\n      return cacheForNullary\n    }\n\n    const payload: RemeshQueryPayload<ExtractSecondArg<T['impl']>, ReturnType<T['impl']>> = {\n      type: 'RemeshQueryPayload',\n      Query,\n      arg,\n    }\n\n    if (arg === undefined) {\n      cacheForNullary = payload\n    }\n\n    return payload\n  }) as RemeshQuery<ExtractSecondArg<T['impl']>, ReturnType<T['impl']>>\n\n  Query.type = 'RemeshQuery'\n  Query.queryId = queryId\n  Query.queryName = options.name\n  Query.prepare = options.prepare\n  Query.impl = options.impl\n  Query.compare = options.compare ?? defaultCompare\n  Query.owner = DefaultDomain()\n  Query.inspectable = options.inspectable ?? true\n  Query.scheduler = options.scheduler\n\n  return Query\n}\n\nexport type RemeshCommandContext = {\n  get: RemeshInjectedContext['get']\n  unwrap: RemeshInjectedContext['unwrap']\n}\n\nexport type RemeshCommandOutput =\n  | RemeshStatePayload<any, any>\n  | RemeshEventPayload<any, any>\n  | RemeshCommandPayload<any>\n  | RemeshCommand$Payload<any>\n  | RemeshCommandOutput[]\n  | null\n\nexport type RemeshCommandPayload<T> = {\n  type: 'RemeshCommandPayload'\n  arg: T\n  Command: RemeshCommand<T>\n}\n\nexport type RemeshCommand<T = unknown> = {\n  type: 'RemeshCommand'\n  commandId: number\n  commandName: string\n  impl: (context: RemeshCommandContext, arg: T) => RemeshCommandOutput\n  (arg: T): RemeshCommandPayload<T>\n  owner: RemeshDomainPayload<any, any>\n  inspectable: boolean\n}\n\nexport type RemeshCommandOptions<T> = {\n  name: string\n  inspectable?: boolean\n  impl: (context: RemeshCommandContext, arg?: T) => RemeshCommandOutput\n}\n\nlet commandUid = 0\n\nexport const RemeshCommand = <T extends RemeshCommandOptions<any>>(\n  options: T,\n): RemeshCommand<ExtractSecondArg<T['impl']>> => {\n  const commandId = commandUid++\n\n  const Command = ((arg) => {\n    return {\n      type: 'RemeshCommandPayload',\n      arg,\n      Command,\n    }\n  }) as RemeshCommand<ExtractSecondArg<T['impl']>>\n\n  Command.type = 'RemeshCommand'\n  Command.commandId = commandId\n  Command.commandName = options.name\n  Command.impl = options.impl\n  Command.owner = DefaultDomain()\n  Command.inspectable = options.inspectable ?? true\n\n  return Command\n}\n\nexport type RemeshCommand$Context = {\n  get: RemeshInjectedContext['get']\n  unwrap: RemeshInjectedContext['unwrap']\n  fromEvent: RemeshInjectedContext['fromEvent']\n  fromQuery: RemeshInjectedContext['fromQuery']\n}\n\nexport type RemeshCommand$Payload<T> = {\n  type: 'RemeshCommand$Payload'\n  arg: T\n  Command$: RemeshCommand$<T>\n}\n\nexport type RemeshCommand$<T> = {\n  type: 'RemeshCommand$'\n  command$Id: number\n  command$Name: string\n  impl: (context: RemeshCommand$Context, arg$: Observable<T>) => Observable<RemeshCommandOutput>\n  (arg: T): RemeshCommand$Payload<T>\n  owner: RemeshDomainPayload<any, any>\n  inspectable: boolean\n}\n\nexport type RemeshCommand$Options<T> = {\n  name: string\n  inspectable?: boolean\n  impl: RemeshCommand$<T>['impl']\n}\nlet command$Uid = 0\n\nexport const RemeshCommand$ = <T = void>(options: RemeshCommand$Options<T>): RemeshCommand$<T> => {\n  const command$Id = command$Uid++\n\n  const Command$ = ((arg) => {\n    return {\n      type: 'RemeshCommand$Payload',\n      arg,\n      Command$,\n    }\n  }) as RemeshCommand$<T>\n\n  Command$.type = 'RemeshCommand$'\n  Command$.command$Id = command$Id\n  Command$.command$Name = options.name\n  Command$.impl = options.impl\n  Command$.owner = DefaultDomain()\n  Command$.inspectable = options.inspectable ?? true\n\n  return Command$\n}\n\nexport type RemeshCommandAsyncOptions<T> = {\n  name: string\n  inspectable?: boolean\n  mode?: 'switch' | 'merge' | 'exhaust' | 'concat'\n  impl: (domain: RemeshCommand$Context, arg?: T) => Promise<RemeshCommandOutput>\n}\n\nexport const RemeshCommandAsync = <T extends RemeshCommandAsyncOptions<any>>(options: T) => {\n  const Command$ = RemeshCommand$<ExtractSecondArg<T['impl']>>({\n    name: options.name,\n    inspectable: options.inspectable,\n    impl: (context, arg$) => {\n      if (!options.mode || options.mode === 'switch') {\n        return arg$.pipe(switchMap((arg) => options.impl(context, arg)))\n      }\n\n      if (options.mode === 'merge') {\n        return arg$.pipe(mergeMap((arg) => options.impl(context, arg)))\n      }\n\n      if (options.mode === 'concat') {\n        return arg$.pipe(concatMap((arg) => options.impl(context, arg)))\n      }\n\n      if (options.mode === 'exhaust') {\n        return arg$.pipe(exhaustMap((arg) => options.impl(context, arg)))\n      }\n\n      throw new Error(`RemeshCommandAsync: invalid mode: ${options.mode}`)\n    },\n  })\n\n  return Command$\n}\n\nexport type RemeshExternPayload<T> = {\n  type: 'RemeshExternPayload'\n  Extern: RemeshExtern<T>\n  value: T\n}\n\nexport type RemeshExtern<T> = {\n  type: 'RemeshExtern'\n  externName: string\n  externId: number\n  default: T\n  (value: T): RemeshExternPayload<T>\n}\n\nexport type RemeshExternOptions<T> = {\n  name: RemeshExtern<T>['externName']\n  default: RemeshExtern<T>['default']\n}\n\nlet externUid = 0\nexport const RemeshExtern = <T = void>(options: RemeshExternOptions<T>): RemeshExtern<T> => {\n  const Extern = ((value) => {\n    return {\n      type: 'RemeshExternPayload',\n      Extern,\n      value,\n    }\n  }) as RemeshExtern<T>\n\n  Extern.externId = externUid++\n  Extern.externName = options.name\n  Extern.default = options.default\n\n  return Extern\n}\n\nexport type RemeshDomainContext = {\n  // definitions\n  state<T>(options: RemeshDefaultStateOptions<T>): RemeshState<void, T>\n  state<T extends RemeshStateOptions<any, any>>(\n    options: T,\n  ): RemeshState<ExtractFirstArg<T['impl']>, ReturnType<T['impl']>>\n  state<T extends SerializableType, U>(options: RemeshDeferStateOptions<T, U>): RemeshState<Undefined2Void<T>, U>\n  event: typeof RemeshEvent\n  query: typeof RemeshQuery\n  command: typeof RemeshCommand\n  command$: typeof RemeshCommand$\n  commandAsync: typeof RemeshCommandAsync\n  // methods\n  getDomain: <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainPayload: RemeshDomainPayload<T, Arg>,\n  ) => T\n  getExtern: <T>(Extern: RemeshExtern<T>) => T\n}\n\nexport type RemeshDomainOutput = {\n  event: {\n    [key: string]: RemeshEvent<any, any>\n  }\n  query: {\n    [key: string]: RemeshQuery<any, any>\n  }\n  command: {\n    [key: string]: RemeshCommand<any> | RemeshCommand$<any>\n  }\n}\n\nexport type RemeshDomainDefinition = Partial<RemeshDomainOutput>\n\nexport type RemeshDomain<T extends RemeshDomainDefinition, Arg extends SerializableType> = {\n  type: 'RemeshDomain'\n  domainName: string\n  domainId: number\n  impl: (context: RemeshDomainContext, arg: Arg) => T\n  (arg: Arg): RemeshDomainPayload<T, Arg>\n  inspectable: boolean\n}\n\nexport type RemeshDomainPayload<T extends RemeshDomainDefinition, Arg extends SerializableType> = {\n  type: 'RemeshDomainPayload'\n  Domain: RemeshDomain<T, Arg>\n  arg: Arg\n}\n\nexport type RemeshDomainOptions<T extends RemeshDomainDefinition, Arg extends SerializableType> = {\n  name: string\n  inspectable?: boolean\n  impl: (context: RemeshDomainContext, arg?: Arg) => T\n}\n\nlet domainUid = 0\n\nexport const RemeshDomain = <T extends RemeshDomainOptions<any, any>>(\n  options: T,\n): RemeshDomain<ReturnType<T['impl']>, ExtractSecondArg<T['impl']>> => {\n  /**\n   * optimize for nullary domain\n   */\n  let cacheForNullary: RemeshDomainPayload<ReturnType<T['impl']>, ExtractSecondArg<T['impl']>> | null = null\n\n  const Domain: RemeshDomain<ReturnType<T['impl']>, ExtractSecondArg<T['impl']>> = ((arg) => {\n    if (arg === undefined && cacheForNullary) {\n      return cacheForNullary\n    }\n\n    const result: RemeshDomainPayload<ReturnType<T['impl']>, ExtractSecondArg<T['impl']>> = {\n      type: 'RemeshDomainPayload',\n      Domain,\n      arg,\n    }\n\n    if (arg === undefined) {\n      cacheForNullary = result\n    }\n\n    return result\n  }) as RemeshDomain<ReturnType<T['impl']>, ExtractSecondArg<T['impl']>>\n\n  Domain.type = 'RemeshDomain'\n  Domain.domainId = domainUid++\n  Domain.domainName = options.name\n  Domain.impl = options.impl\n  Domain.inspectable = options.inspectable ?? true\n\n  return Domain\n}\n\nexport const DefaultDomain: RemeshDomain<any, void> = RemeshDomain({\n  name: 'DefaultDomain',\n  impl: () => {\n    return {}\n  },\n})\n","import {\n  RemeshDomain,\n  RemeshCommand$Payload,\n  RemeshCommandPayload,\n  RemeshEventPayload,\n  SerializableType,\n} from './remesh'\n\nimport type {\n  RemeshStoreOptions,\n  RemeshDomainStorage,\n  RemeshStateStorage,\n  RemeshQueryStorage,\n  RemeshStore,\n  RemeshStoreInspector,\n} from './store'\n\nexport type RemeshDomainStorageEventData<T, U extends SerializableType> = {\n  type: 'Domain::Created' | 'Domain::Destroyed' | 'Domain::Restored'\n  storage: RemeshDomainStorage<T, U>\n}\n\nexport type RemeshStateStorageEventData<T extends SerializableType, U> = {\n  type: 'State::Created' | 'State::Updated' | 'State::Destroyed' | 'State::Restored'\n  storage: RemeshStateStorage<T, U>\n}\n\nexport type RemeshQueryStorageEventData<T extends SerializableType, U> = {\n  type: 'Query::Created' | 'Query::Updated' | 'Query::Destroyed' | 'Query::Restored'\n  storage: RemeshQueryStorage<T, U>\n}\n\nexport type RemeshEventEmittedEventData<T, U> = {\n  type: 'Event::Emitted'\n  payload: RemeshEventPayload<T, U>\n}\n\nexport type RemeshCommandReceivedEventData<T> = {\n  type: 'Command::Received'\n  payload: RemeshCommandPayload<T>\n}\n\nexport type RemeshCommand$ReceivedEventData<T> = {\n  type: 'Command$::Received'\n  payload: RemeshCommand$Payload<T>\n}\n\nexport const InspectorType = {\n  DomainCreated: 'Domain::Created',\n  DomainDestroyed: 'Domain::Destroyed',\n  DomainRestored: 'Domain::Restored',\n  StateCreated: 'State::Created',\n  StateUpdated: 'State::Updated',\n  StateDestroyed: 'State::Destroyed',\n  StateRestored: 'State::Restored',\n  QueryCreated: 'Query::Created',\n  QueryUpdated: 'Query::Updated',\n  QueryDestroyed: 'Query::Destroyed',\n  QueryRestored: 'Query::Restored',\n  EventEmitted: 'Event::Emitted',\n  CommandReceived: 'Command::Received',\n  Command$Received: 'Command$::Received',\n} as const\n\nexport const RemeshInspectorDomain = RemeshDomain({\n  name: 'RemeshInspector',\n  impl: (domain) => {\n    const RemeshDomainStorageEvent = domain.event<RemeshDomainStorageEventData<any, any>>({\n      name: 'RemeshDomainStorageEvent',\n    })\n\n    const RemeshStateStorageEvent = domain.event<RemeshStateStorageEventData<any, any>>({\n      name: 'RemeshStateStorageEvent',\n    })\n\n    const RemeshQueryStorageEvent = domain.event<RemeshQueryStorageEventData<any, any>>({\n      name: 'RemeshQueryStorageEvent',\n    })\n\n    const RemeshEventEmittedEvent = domain.event<RemeshEventEmittedEventData<any, any>>({\n      name: 'RemeshEventEmitted',\n    })\n\n    const RemeshCommandReceivedEvent = domain.event<RemeshCommandReceivedEventData<any>>({\n      name: 'RemeshCommandReceived',\n    })\n\n    const RemeshCommand$ReceivedEvent = domain.event<RemeshCommand$ReceivedEventData<any>>({\n      name: 'RemeshCommand$Received',\n    })\n\n    return {\n      event: {\n        RemeshDomainStorageEvent,\n        RemeshStateStorageEvent,\n        RemeshQueryStorageEvent,\n        RemeshEventEmittedEvent,\n        RemeshCommandReceivedEvent,\n        RemeshCommand$ReceivedEvent,\n      },\n    }\n  },\n})\n\nexport type InspectInput = {\n  inspectable: boolean\n  owner?: {\n    Domain: {\n      inspectable: boolean\n    }\n  }\n}\n\nexport const isInspectable = (input: InspectInput): boolean => {\n  if (input.owner) {\n    return input.owner.Domain.inspectable && input.inspectable\n  }\n  return input.inspectable\n}\n\nconst initInspectors = (options: RemeshStoreOptions) => {\n  return (options.inspectors ?? [])\n    .filter((inspector): inspector is RemeshStoreInspector => !!inspector)\n    .map((inspector) => {\n      const { inspectors, ...rest } = options\n      return inspector(rest)\n    })\n}\n\nexport const createInspectorManager = (options: RemeshStoreOptions) => {\n  let inspectors: RemeshStore[] | null = null\n\n  const getInspectors = (): RemeshStore[] => {\n    if (!inspectors) {\n      inspectors = initInspectors(options)\n    }\n\n    return inspectors\n  }\n\n  const destroyInspectors = () => {\n    if (inspectors) {\n      for (const inspector of inspectors) {\n        inspector.destroy()\n      }\n\n      inspectors = null\n    }\n  }\n\n  const inspectDomainStorage = <T, U extends SerializableType>(\n    type: RemeshDomainStorageEventData<T, U>['type'],\n    domainStorage: RemeshDomainStorage<T, U>,\n  ) => {\n    if (isInspectable(domainStorage.Domain)) {\n      for (const inspector of getInspectors()) {\n        const inspectorDomain = inspector.getDomain(RemeshInspectorDomain())\n        const event = inspectorDomain.event.RemeshDomainStorageEvent({\n          type,\n          storage: domainStorage,\n        })\n        inspector.emitEvent(event)\n      }\n    }\n  }\n\n  const inspectStateStorage = <T extends SerializableType, U>(\n    type: RemeshStateStorageEventData<T, U>['type'],\n    stateStorage: RemeshStateStorage<T, U>,\n  ) => {\n    if (isInspectable(stateStorage.State)) {\n      for (const inspector of getInspectors()) {\n        const inspectorDomain = inspector.getDomain(RemeshInspectorDomain())\n        const event = inspectorDomain.event.RemeshStateStorageEvent({\n          type,\n          storage: stateStorage,\n        })\n        inspector.emitEvent(event)\n      }\n    }\n  }\n\n  const inspectQueryStorage = <T extends SerializableType, U>(\n    type: RemeshQueryStorageEventData<T, U>['type'],\n    queryStorage: RemeshQueryStorage<T, U>,\n  ) => {\n    if (isInspectable(queryStorage.Query)) {\n      for (const inspector of getInspectors()) {\n        const inspectorDomain = inspector.getDomain(RemeshInspectorDomain())\n        const event = inspectorDomain.event.RemeshQueryStorageEvent({\n          type,\n          storage: queryStorage,\n        })\n        inspector.emitEvent(event)\n      }\n    }\n  }\n\n  const inspectEventEmitted = <T, U>(\n    type: RemeshEventEmittedEventData<T, U>['type'],\n    eventPayload: RemeshEventPayload<T, U>,\n  ) => {\n    if (isInspectable(eventPayload.Event)) {\n      for (const inspector of getInspectors()) {\n        const inspectorDomain = inspector.getDomain(RemeshInspectorDomain())\n        const event = inspectorDomain.event.RemeshEventEmittedEvent({\n          type,\n          payload: eventPayload,\n        })\n        inspector.emitEvent(event)\n      }\n    }\n  }\n\n  const inspectCommandReceived = <T>(\n    type: RemeshCommandReceivedEventData<T>['type'],\n    commandPayload: RemeshCommandPayload<T>,\n  ) => {\n    if (isInspectable(commandPayload.Command)) {\n      for (const inspector of getInspectors()) {\n        const inspectorDomain = inspector.getDomain(RemeshInspectorDomain())\n        const event = inspectorDomain.event.RemeshCommandReceivedEvent({\n          type,\n          payload: commandPayload,\n        })\n        inspector.emitEvent(event)\n      }\n    }\n  }\n\n  const inspectCommand$Received = <T>(\n    type: RemeshCommand$ReceivedEventData<T>['type'],\n    command$Payload: RemeshCommand$Payload<T>,\n  ) => {\n    if (isInspectable(command$Payload.Command$)) {\n      for (const inspector of getInspectors()) {\n        const inspectorDomain = inspector.getDomain(RemeshInspectorDomain())\n        const event = inspectorDomain.event.RemeshCommand$ReceivedEvent({\n          type,\n          payload: command$Payload,\n        })\n        inspector.emitEvent(event)\n      }\n    }\n  }\n\n  return {\n    destroyInspectors,\n    inspectDomainStorage,\n    inspectStateStorage,\n    inspectQueryStorage,\n    inspectEventEmitted,\n    inspectCommandReceived,\n    inspectCommand$Received,\n  }\n}\n","import { Observable } from 'rxjs'\n\nexport type PendingPromiseData = {\n  type: 'pending'\n}\n\nexport type ResolvedPromiseData<T> = {\n  type: 'resolved'\n  value: T\n}\n\nexport type RejectedPromiseData = {\n  type: 'rejected'\n  error: Error\n}\n\nexport type PromiseData<T> = PendingPromiseData | ResolvedPromiseData<T> | RejectedPromiseData\n\nconst promiseObservableWeakMap = new WeakMap<Promise<any>, Observable<PromiseData<any>>>()\n\nexport const promiseToObservable = <T>(promise: Promise<T>): Observable<PromiseData<T>> => {\n  if (promiseObservableWeakMap.has(promise)) {\n    return promiseObservableWeakMap.get(promise)!\n  }\n\n  let promiseData: PromiseData<T> | null = null\n  const observable: Observable<PromiseData<T>> = new Observable((subscriber) => {\n    if (promiseData) {\n      subscriber.next(promiseData)\n      subscriber.complete()\n      return\n    }\n\n    subscriber.next({ type: 'pending' })\n\n    promise.then(\n      (value) => {\n        const resolvedData: ResolvedPromiseData<T> = { type: 'resolved', value }\n        promiseData = resolvedData\n        subscriber.next(resolvedData)\n        subscriber.complete()\n      },\n      (error) => {\n        const rejectedData: RejectedPromiseData = { type: 'rejected', error }\n        promiseData = rejectedData\n        subscriber.next(rejectedData)\n        subscriber.complete()\n      },\n    )\n  })\n\n  promiseObservableWeakMap.set(promise, observable)\n\n  return observable\n}\n\nconst promiseWeakMap = new WeakMap<Promise<any>, PromiseData<any>>()\n\nexport const getPromiseData = function <T>(promise: Promise<T>): PromiseData<T> {\n  if (!promiseWeakMap.has(promise)) {\n    promiseWeakMap.set(promise, { type: 'pending' })\n\n    promise.then(\n      (value) => {\n        promiseWeakMap.set(promise, { type: 'resolved', value })\n      },\n      (error) => {\n        if (error instanceof Error) {\n          promiseWeakMap.set(promise, { type: 'rejected', error })\n        } else {\n          promiseWeakMap.set(promise, { type: 'rejected', error: new Error(error) })\n        }\n      },\n    )\n  }\n\n  return promiseWeakMap.get(promise)!\n}\n","import { Observable, Observer, Subject, Subscription } from 'rxjs'\n\nimport { map, startWith, switchMap } from 'rxjs/operators'\n\nimport {\n  RemeshCommand,\n  RemeshCommand$,\n  RemeshCommand$Context,\n  RemeshCommand$Payload,\n  RemeshCommandAsync,\n  RemeshCommandContext,\n  RemeshCommandOutput,\n  RemeshCommandPayload,\n  RemeshDefaultState,\n  RemeshDefaultStateOptions,\n  RemeshDeferState,\n  RemeshDeferStateOptions,\n  RemeshDomain,\n  RemeshDomainContext,\n  RemeshDomainDefinition,\n  RemeshDomainPayload,\n  RemeshEvent,\n  RemeshEventOptions,\n  RemeshEventPayload,\n  RemeshExtern,\n  RemeshExternPayload,\n  RemeshInjectedContext,\n  RemeshQuery,\n  RemeshQueryContext,\n  RemeshQueryPayload,\n  RemeshState,\n  RemeshStateItem,\n  RemeshStateOptions,\n  RemeshStatePayload,\n  SerializableType,\n} from './remesh'\n\nimport { createInspectorManager, InspectorType } from './inspector'\nimport { getPromiseData, PromiseData, promiseToObservable } from './promise'\n\nexport type RemeshStore = ReturnType<typeof RemeshStore>\n\nexport const RemeshValuePlaceholder = Symbol('RemeshValuePlaceholder')\n\nexport type RemeshValuePlaceholder = typeof RemeshValuePlaceholder\n\nlet uid = 0\n\nexport type RemeshStateStorage<T extends SerializableType, U> = {\n  id: number\n  type: 'RemeshStateStorage'\n  State: RemeshState<T, U>\n  arg: T\n  key: string\n  currentState: U | RemeshValuePlaceholder\n  downstreamSet: Set<RemeshQueryStorage<any, any>>\n}\n\nexport type RemeshQueryStorage<T extends SerializableType, U> = {\n  id: number\n  type: 'RemeshQueryStorage'\n  Query: RemeshQuery<T, U>\n  arg: T\n  key: string\n  currentValue: U | RemeshValuePlaceholder\n  upstreamSet: Set<RemeshQueryStorage<any, any> | RemeshStateStorage<any, any>>\n  downstreamSet: Set<RemeshQueryStorage<any, any>>\n  subject: Subject<U>\n  observable: Observable<U>\n  schedulerSubject?: Subject<U>\n  refCount: number\n}\n\nexport type RemeshEventStorage<T = unknown, U = T> = {\n  id: number\n  type: 'RemeshEventStorage'\n  Event: RemeshEvent<T, U>\n  subject: Subject<U>\n  observable: Observable<U>\n  refCount: number\n}\n\nexport type RemeshCommand$Storage<T> = {\n  id: number\n  type: 'RemeshCommand$Storage'\n  Command$: RemeshCommand$<T>\n  subject: Subject<T>\n  observable: Observable<T>\n  subscription?: Subscription\n}\n\nexport type RemeshDomainStorage<T extends RemeshDomainDefinition, Arg extends SerializableType> = {\n  id: number\n  type: 'RemeshDomainStorage'\n  Domain: RemeshDomain<T, Arg>\n  arg: Arg\n  key: string\n  domain: T\n  domainContext: RemeshDomainContext\n  domainOutput?: BindingDomainOutput<T>\n  domainPayload: RemeshDomainPayload<T, Arg>\n  upstreamSet: Set<RemeshDomainStorage<any, any>>\n  downstreamSet: Set<RemeshDomainStorage<any, any>>\n  domainSubscriptionSet: Set<Subscription>\n  upstreamSubscriptionSet: Set<Subscription>\n  command$Set: Set<RemeshCommand$<any>>\n  stateMap: Map<string, RemeshStateStorage<any, any>>\n  queryMap: Map<string, RemeshQueryStorage<any, any>>\n  eventMap: Map<RemeshEvent<any, any>, RemeshEventStorage<any, any>>\n  command$Map: Map<RemeshCommand$<any>, RemeshCommand$Storage<any>>\n  refCount: number\n  running: boolean\n}\n\nexport type RemeshExternStorage<T> = {\n  id: number\n  type: 'RemeshExternStorage'\n  Extern: RemeshExtern<T>\n  currentValue: T\n}\n\nexport type RemeshStoreInspector = typeof RemeshStore\n\nexport type RemeshStoreOptions = {\n  name?: string\n  externs?: RemeshExternPayload<any>[]\n  inspectors?: (RemeshStoreInspector | false | undefined | null)[]\n}\n\nexport type BindingCommand<T extends RemeshDomainDefinition['command']> = T extends {}\n  ? {\n      [key in keyof T]: (...args: Parameters<T[key]>) => void\n    }\n  : never\n\nexport type BindingDomainOutput<T extends RemeshDomainDefinition> = Omit<T, 'command'> & {\n  command: BindingCommand<T['command']>\n}\n\ntype PendingClearItem =\n  | RemeshStateStorage<any, any>\n  | RemeshDomainStorage<any, any>\n  | RemeshEventStorage<any, any>\n  | RemeshQueryStorage<any, any>\n\nexport const RemeshStore = (options?: RemeshStoreOptions) => {\n  const config = {\n    ...options,\n  }\n\n  const inspectorManager = createInspectorManager(config)\n\n  const dirtySet = new Set<RemeshQueryStorage<any, any>>()\n  const domainStorageMap = new Map<string, RemeshDomainStorage<any, any>>()\n  const pendingStorageSet = new Set<PendingClearItem>()\n  const externStorageWeakMap = new WeakMap<RemeshExtern<any>, RemeshExternStorage<any>>()\n\n  const getExternValue = <T>(Extern: RemeshExtern<T>): T => {\n    for (const payload of config.externs ?? []) {\n      if (payload.Extern === Extern) {\n        return payload.value\n      }\n    }\n    return Extern.default\n  }\n\n  const getExternStorage = <T>(Extern: RemeshExtern<T>): RemeshExternStorage<T> => {\n    const externStorage = externStorageWeakMap.get(Extern)\n\n    if (externStorage) {\n      return externStorage\n    }\n\n    const currentValue = getExternValue(Extern)\n\n    const currentExternStorage: RemeshExternStorage<T> = {\n      id: uid++,\n      type: 'RemeshExternStorage',\n      Extern,\n      currentValue,\n    }\n\n    externStorageWeakMap.set(Extern, currentExternStorage)\n\n    return currentExternStorage\n  }\n\n  const getExternCurrentValue = <T>(Extern: RemeshExtern<T>): T => {\n    return getExternStorage(Extern).currentValue\n  }\n\n  const storageKeyWeakMap = new WeakMap<\n    RemeshQueryPayload<any, any> | RemeshStateItem<any, any> | RemeshDomainPayload<any, any>,\n    string\n  >()\n\n  const getStateStorageKey = <T extends SerializableType, U>(stateItem: RemeshStateItem<T, U>): string => {\n    const key = storageKeyWeakMap.get(stateItem)\n\n    if (key) {\n      return key\n    }\n\n    const stateName = stateItem.State.stateName\n    const argString = JSON.stringify(stateItem.arg) ?? ''\n    const keyString = `State/${stateItem.State.stateId}/${stateName}:${argString}`\n\n    storageKeyWeakMap.set(stateItem, keyString)\n\n    return keyString\n  }\n\n  const getQueryStorageKey = <T extends SerializableType, U>(queryPayload: RemeshQueryPayload<T, U>): string => {\n    const key = storageKeyWeakMap.get(queryPayload)\n\n    if (key) {\n      return key\n    }\n\n    const queryName = queryPayload.Query.queryName\n    const argString = JSON.stringify(queryPayload.arg) ?? ''\n    const keyString = `Query/${queryPayload.Query.queryId}/${queryName}:${argString}`\n\n    storageKeyWeakMap.set(queryPayload, keyString)\n\n    return keyString\n  }\n\n  const getDomainStorageKey = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainPayload: RemeshDomainPayload<T, Arg>,\n  ): string => {\n    const key = storageKeyWeakMap.get(domainPayload)\n\n    if (key) {\n      return key\n    }\n\n    const domainName = domainPayload.Domain.domainName\n    const argString = JSON.stringify(domainPayload.arg) ?? ''\n    const keyString = `Domain/${domainPayload.Domain.domainId}/${domainName}:${argString}`\n\n    storageKeyWeakMap.set(domainPayload, keyString)\n\n    return keyString\n  }\n\n  const getStorageKey = <T extends SerializableType, U>(\n    input: RemeshStateItem<T, U> | RemeshQueryPayload<T, U> | RemeshDomainPayload<U, T>,\n  ): string => {\n    if (input.type === 'RemeshStateItem') {\n      return getStateStorageKey(input)\n    } else if (input.type === 'RemeshQueryPayload') {\n      return getQueryStorageKey(input)\n    }\n    return getDomainStorageKey(input)\n  }\n\n  const getStateFromStorage = <T extends SerializableType, U>(storage: RemeshStateStorage<T, U>): U => {\n    if (storage.currentState === RemeshValuePlaceholder) {\n      throw new Error(`State ${storage.key} is not found`)\n    }\n    return storage.currentState\n  }\n\n  const stateStorageWeakMap = new WeakMap<RemeshStateItem<any, any>, RemeshStateStorage<any, any>>()\n\n  const createStateStorage = <T extends SerializableType, U>(\n    stateItem: RemeshStateItem<T, U>,\n  ): RemeshStateStorage<T, U> => {\n    const domainStorage = getDomainStorage(stateItem.State.owner)\n    const key = getStateStorageKey(stateItem)\n\n    const currentState = stateItem.State.defer ? RemeshValuePlaceholder : stateItem.State.impl(stateItem.arg)\n\n    const newStateStorage: RemeshStateStorage<T, U> = {\n      id: uid++,\n      type: 'RemeshStateStorage',\n      State: stateItem.State,\n      arg: stateItem.arg,\n      key,\n      currentState,\n      downstreamSet: new Set(),\n    }\n\n    domainStorage.stateMap.set(key, newStateStorage)\n    stateStorageWeakMap.set(stateItem, newStateStorage)\n\n    inspectorManager.inspectStateStorage(InspectorType.StateCreated, newStateStorage)\n\n    return newStateStorage\n  }\n\n  const restoreStateStorage = <T extends SerializableType, U>(stateStorage: RemeshStateStorage<T, U>) => {\n    const domainStorage = getDomainStorage(stateStorage.State.owner)\n\n    if (domainStorage.stateMap.has(stateStorage.key)) {\n      return\n    }\n\n    domainStorage.stateMap.set(stateStorage.key, stateStorage)\n    inspectorManager.inspectStateStorage(InspectorType.StateRestored, stateStorage)\n  }\n\n  const getStateStorage = <T extends SerializableType, U>(\n    stateItem: RemeshStateItem<T, U>,\n  ): RemeshStateStorage<T, U> => {\n    const domainStorage = getDomainStorage(stateItem.State.owner)\n    const key = getStateStorageKey(stateItem)\n    const stateStorage = domainStorage.stateMap.get(key)\n\n    if (stateStorage) {\n      return stateStorage as RemeshStateStorage<T, U>\n    }\n\n    const cachedStorage = stateStorageWeakMap.get(stateItem)\n\n    if (cachedStorage) {\n      restoreStateStorage(cachedStorage)\n      return cachedStorage\n    }\n\n    return createStateStorage(stateItem)\n  }\n\n  const eventStorageWeakMap = new WeakMap<RemeshEvent<any, any>, RemeshEventStorage<any, any>>()\n\n  const createEventStorage = <T, U = T>(Event: RemeshEvent<T, U>): RemeshEventStorage<T, U> => {\n    const domainStorage = getDomainStorage(Event.owner)\n\n    const subject = new Subject<U>()\n\n    const observable = new Observable<U>((subscriber) => {\n      const subscription = subject.subscribe(subscriber)\n      currentEventStorage.refCount += 1\n      return () => {\n        subscription.unsubscribe()\n        currentEventStorage.refCount -= 1\n        pendingStorageSet.add(currentEventStorage)\n        clearPendingStorageSetIfNeeded()\n      }\n    })\n\n    const cachedStorage = eventStorageWeakMap.get(Event)\n\n    const currentEventStorage = Object.assign(cachedStorage ?? {}, {\n      type: 'RemeshEventStorage',\n      Event,\n      subject,\n      observable,\n      refCount: 0,\n    } as RemeshEventStorage<T, U>)\n\n    domainStorage.eventMap.set(Event, currentEventStorage)\n    eventStorageWeakMap.set(Event, currentEventStorage)\n\n    return currentEventStorage\n  }\n\n  const getEventStorage = <T, U = T>(Event: RemeshEvent<T, U>): RemeshEventStorage<T, U> => {\n    const domainStorage = getDomainStorage(Event.owner)\n    const eventStorage = domainStorage.eventMap.get(Event)\n\n    if (eventStorage) {\n      return eventStorage as RemeshEventStorage<T, U>\n    }\n\n    return createEventStorage(Event)\n  }\n\n  const queryStorageWeakMap = new WeakMap<RemeshQueryPayload<any, any>, RemeshQueryStorage<any, any>>()\n\n  const createQuery$ = <T extends SerializableType, U>(get: () => RemeshQueryStorage<T, U>) => {\n    const subject = new Subject<U>()\n\n    const observable = new Observable<U>((subscriber) => {\n      const subscription = subject.subscribe(subscriber)\n      const queryStorage = get()\n      queryStorage.refCount += 1\n\n      return () => {\n        subscription.unsubscribe()\n        queryStorage.refCount -= 1\n        pendingStorageSet.add(queryStorage)\n        clearPendingStorageSetIfNeeded()\n      }\n    })\n\n    return {\n      subject,\n      observable,\n    }\n  }\n\n  const prepareQuery = <T extends SerializableType, U>(\n    Query: RemeshQuery<T, U>,\n    queryContext: RemeshQueryContext,\n    arg: T,\n  ) => {\n    if (!Query.prepare) {\n      return\n    }\n\n    const result = Query.prepare(queryContext, arg)\n\n    if (!result) {\n      return\n    }\n\n    if (Array.isArray(result)) {\n      for (const statePayload of result) {\n        handleStatePayload(statePayload)\n      }\n      return\n    }\n\n    handleStatePayload(result)\n  }\n\n  const handleQueryScheduler = <T extends SerializableType, U>(queryStorage: RemeshQueryStorage<T, U>) => {\n    if (!queryStorage.Query.scheduler) {\n      return\n    }\n\n    const schedulerSubject = new Subject<U>()\n\n    queryStorage.schedulerSubject = schedulerSubject\n\n    const schedulerContext = {\n      get: remeshInjectedContext.get,\n      get unwrap() {\n        return remeshInjectedContext.unwrap.bind(schedulerContext)\n      },\n      fromEvent: remeshInjectedContext.fromEvent,\n      fromQuery: remeshInjectedContext.fromQuery,\n    }\n\n    const scheduler = queryStorage.Query.scheduler(schedulerContext, schedulerSubject.asObservable())\n\n    scheduler.subscribe(() => {\n      updateQueryStorageImmediately(queryStorage)\n      commit()\n    })\n  }\n\n  const createQueryStorage = <T extends SerializableType, U>(\n    queryPayload: RemeshQueryPayload<T, U>,\n  ): RemeshQueryStorage<T, U> => {\n    const domainStorage = getDomainStorage(queryPayload.Query.owner)\n    const key = getQueryStorageKey(queryPayload)\n\n    const { subject, observable } = createQuery$(() => currentQueryStorage)\n    const upstreamSet: RemeshQueryStorage<T, U>['upstreamSet'] = new Set()\n\n    const currentQueryStorage: RemeshQueryStorage<T, U> = {\n      id: uid++,\n      type: 'RemeshQueryStorage',\n      Query: queryPayload.Query,\n      arg: queryPayload.arg,\n      currentValue: RemeshValuePlaceholder,\n      key,\n      upstreamSet,\n      downstreamSet: new Set(),\n      subject,\n      observable,\n      refCount: 0,\n    }\n\n    const { Query } = queryPayload\n\n    handleQueryScheduler(currentQueryStorage)\n\n    const queryContext: RemeshQueryContext = {\n      get: (input) => {\n        if (currentQueryStorage.upstreamSet !== upstreamSet) {\n          return remeshInjectedContext.get(input)\n        }\n\n        if (input.type === 'RemeshStateItem') {\n          const upstreamStateStorage = getStateStorage(input)\n\n          currentQueryStorage.upstreamSet.add(upstreamStateStorage)\n          upstreamStateStorage.downstreamSet.add(currentQueryStorage)\n\n          return remeshInjectedContext.get(input)\n        }\n\n        if (input.type === 'RemeshQueryPayload') {\n          const upstreamQueryStorage = getQueryStorage(input)\n\n          currentQueryStorage.upstreamSet.add(upstreamQueryStorage)\n          upstreamQueryStorage.downstreamSet.add(currentQueryStorage)\n\n          return remeshInjectedContext.get(input)\n        }\n\n        return remeshInjectedContext.get(input)\n      },\n      get unwrap() {\n        return remeshInjectedContext.unwrap.bind(queryContext)\n      },\n    }\n\n    prepareQuery(Query, queryContext, queryPayload.arg)\n\n    const currentValue = Query.impl(queryContext, queryPayload.arg)\n\n    if (currentValue instanceof Promise) {\n      getPromiseData(currentValue)\n    }\n\n    currentQueryStorage.currentValue = currentValue\n\n    domainStorage.queryMap.set(key, currentQueryStorage)\n    queryStorageWeakMap.set(queryPayload, currentQueryStorage)\n\n    inspectorManager.inspectQueryStorage(InspectorType.QueryCreated, currentQueryStorage)\n\n    return currentQueryStorage\n  }\n\n  const restoreQueryStorage = <T extends SerializableType, U>(queryStorage: RemeshQueryStorage<T, U>) => {\n    const domainStorage = getDomainStorage(queryStorage.Query.owner)\n\n    if (domainStorage.queryMap.has(queryStorage.key)) {\n      return\n    }\n\n    const { subject, observable } = createQuery$(() => queryStorage)\n\n    queryStorage.subject = subject\n    queryStorage.observable = observable\n    domainStorage.queryMap.set(queryStorage.key, queryStorage)\n\n    handleQueryScheduler(queryStorage)\n\n    for (const upstream of queryStorage.upstreamSet) {\n      upstream.downstreamSet.add(queryStorage)\n      if (upstream.type === 'RemeshQueryStorage') {\n        restoreQueryStorage(upstream)\n      } else if (upstream.type === 'RemeshStateStorage') {\n        restoreStateStorage(upstream)\n      } else {\n        throw new Error(`Unknown upstream: ${upstream}`)\n      }\n    }\n\n    inspectorManager.inspectQueryStorage(InspectorType.QueryRestored, queryStorage)\n    updateQueryStorage(queryStorage)\n  }\n\n  const getQueryStorage = <T extends SerializableType, U>(\n    queryPayload: RemeshQueryPayload<T, U>,\n  ): RemeshQueryStorage<T, U> => {\n    const domainStorage = getDomainStorage(queryPayload.Query.owner)\n    const key = getQueryStorageKey(queryPayload)\n    const queryStorage = domainStorage.queryMap.get(key)\n\n    if (queryStorage) {\n      return queryStorage\n    }\n\n    const cachedStorage = queryStorageWeakMap.get(queryPayload)\n\n    if (cachedStorage) {\n      restoreQueryStorage(cachedStorage)\n      return cachedStorage\n    }\n\n    return createQueryStorage(queryPayload)\n  }\n\n  const command$StorageWeakMap = new WeakMap<RemeshCommand$<any>, RemeshCommand$Storage<any>>()\n\n  const createCommand$Storage = <T>(Command$: RemeshCommand$<T>): RemeshCommand$Storage<T> => {\n    const domainStorage = getDomainStorage(Command$.owner)\n    const subject = new Subject<T>()\n    const observable = subject.asObservable()\n\n    const currentCommand$Storage: RemeshCommand$Storage<T> = {\n      id: uid++,\n      type: 'RemeshCommand$Storage',\n      Command$,\n      subject,\n      observable,\n    }\n\n    domainStorage.command$Map.set(Command$, currentCommand$Storage)\n    command$StorageWeakMap.set(Command$, currentCommand$Storage)\n\n    return currentCommand$Storage\n  }\n\n  const getCommand$Storage = <T>(Command$: RemeshCommand$<T>): RemeshCommand$Storage<T> => {\n    const domainStorage = getDomainStorage(Command$.owner)\n    const command$Storage = domainStorage.command$Map.get(Command$)\n\n    if (command$Storage) {\n      return command$Storage\n    }\n\n    const cachedStorage = command$StorageWeakMap.get(Command$)\n\n    if (cachedStorage) {\n      const subject = new Subject<T>()\n      const observable = subject.asObservable()\n\n      cachedStorage.subject = subject\n      cachedStorage.observable = observable\n      cachedStorage.subscription = undefined\n      domainStorage.command$Map.set(Command$, cachedStorage)\n\n      return cachedStorage\n    }\n\n    return createCommand$Storage(Command$)\n  }\n\n  const domainStorageWeakMap = new WeakMap<RemeshDomainPayload<any, any>, RemeshDomainStorage<any, any>>()\n\n  const createDomainStorage = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainPayload: RemeshDomainPayload<T, Arg>,\n  ): RemeshDomainStorage<T, Arg> => {\n    const key = getDomainStorageKey(domainPayload)\n\n    let isDomainInited = false\n\n    const upstreamSet: RemeshDomainStorage<T, Arg>['upstreamSet'] = new Set()\n    const command$Set: RemeshDomainStorage<T, Arg>['command$Set'] = new Set()\n\n    const domainContext: RemeshDomainContext = {\n      state: (\n        options:\n          | RemeshStateOptions<any, unknown>\n          | RemeshDefaultStateOptions<unknown>\n          | RemeshDeferStateOptions<any, unknown>,\n      ): any => {\n        if ('default' in options) {\n          const DefaultState = RemeshDefaultState(options)\n          DefaultState.owner = domainPayload\n          DefaultState.Query.owner = domainPayload\n          return DefaultState\n        }\n\n        if (!('impl' in options)) {\n          const DeferState = RemeshDeferState(options)\n          DeferState.owner = domainPayload\n          DeferState.Query.owner = domainPayload\n          return DeferState\n        }\n\n        const State = RemeshState(options)\n        State.owner = domainPayload\n        State.Query.owner = domainPayload\n        return State\n      },\n      query: (options) => {\n        const Query = RemeshQuery(options)\n        Query.owner = domainPayload\n        return Query\n      },\n      event: (options: { name: string } | RemeshEventOptions<any, any>) => {\n        const Event = RemeshEvent(options)\n        Event.owner = domainPayload\n        return Event as RemeshEvent<any, any>\n      },\n      command: (options) => {\n        const Command = RemeshCommand(options)\n        Command.owner = domainPayload\n        return Command\n      },\n      command$: (options) => {\n        const Command$ = RemeshCommand$(options)\n\n        Command$.owner = domainPayload\n        command$Set.add(Command$)\n\n        if (isDomainInited) {\n          initCommand$IfNeeded(Command$)\n        }\n\n        return Command$\n      },\n      commandAsync: (options) => {\n        const Command$ = RemeshCommandAsync(options)\n\n        Command$.owner = domainPayload\n        command$Set.add(Command$)\n\n        if (isDomainInited) {\n          initCommand$IfNeeded(Command$)\n        }\n\n        return Command$\n      },\n      getDomain: (UpstreamDomain) => {\n        const upstreamDomainStorage = getDomainStorage(UpstreamDomain)\n\n        upstreamSet.add(upstreamDomainStorage)\n\n        return upstreamDomainStorage.domain\n      },\n      getExtern: (Extern) => {\n        return getExternCurrentValue(Extern)\n      },\n    }\n\n    const domain = domainPayload.Domain.impl(domainContext, domainPayload.arg)\n\n    isDomainInited = true\n    const currentDomainStorage: RemeshDomainStorage<T, Arg> = {\n      id: uid++,\n      type: 'RemeshDomainStorage',\n      Domain: domainPayload.Domain,\n      arg: domainPayload.arg,\n      domain,\n      domainContext,\n      domainPayload,\n      key,\n      command$Set,\n      upstreamSet,\n      downstreamSet: new Set(),\n      upstreamSubscriptionSet: new Set(),\n      domainSubscriptionSet: new Set(),\n      stateMap: new Map(),\n      queryMap: new Map(),\n      eventMap: new Map(),\n      command$Map: new Map(),\n      refCount: 0,\n      running: false,\n    }\n\n    domainStorageMap.set(key, currentDomainStorage)\n    domainStorageWeakMap.set(domainPayload, currentDomainStorage)\n\n    inspectorManager.inspectDomainStorage(InspectorType.DomainCreated, currentDomainStorage)\n\n    for (const upstreamDomainStorage of upstreamSet) {\n      upstreamDomainStorage.downstreamSet.add(currentDomainStorage)\n    }\n\n    return currentDomainStorage\n  }\n\n  const getDomainStorage = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainPayload: RemeshDomainPayload<T, Arg>,\n  ): RemeshDomainStorage<T, Arg> => {\n    const key = getDomainStorageKey(domainPayload)\n    const domainStorage = domainStorageMap.get(key)\n\n    if (domainStorage) {\n      return domainStorage\n    }\n\n    const cachedStorage = domainStorageWeakMap.get(domainPayload)\n\n    if (cachedStorage) {\n      cachedStorage.running = false\n      domainStorageMap.set(cachedStorage.key, cachedStorage)\n\n      for (const upstreamDomainStorage of cachedStorage.upstreamSet) {\n        upstreamDomainStorage.downstreamSet.add(cachedStorage)\n      }\n\n      inspectorManager.inspectDomainStorage(InspectorType.DomainRestored, cachedStorage)\n      return cachedStorage\n    }\n\n    return createDomainStorage(domainPayload)\n  }\n\n  const clearQueryStorage = <T extends SerializableType, U>(queryStorage: RemeshQueryStorage<T, U>) => {\n    const domainStorage = getDomainStorage(queryStorage.Query.owner)\n\n    if (!domainStorage.queryMap.has(queryStorage.key)) {\n      return\n    }\n\n    domainStorage.queryMap.delete(queryStorage.key)\n\n    inspectorManager.inspectQueryStorage(InspectorType.QueryDestroyed, queryStorage)\n\n    for (const upstreamStorage of queryStorage.upstreamSet) {\n      upstreamStorage.downstreamSet.delete(queryStorage)\n\n      if (upstreamStorage.type === 'RemeshQueryStorage') {\n        clearQueryStorageIfNeeded(upstreamStorage)\n      } else if (upstreamStorage.type === 'RemeshStateStorage') {\n        clearStateStorageIfNeeded(upstreamStorage)\n      } else {\n        throw new Error(`Unknown upstream in clearQueryStorageIfNeeded(..): ${upstreamStorage}`)\n      }\n    }\n\n    queryStorage.schedulerSubject?.complete()\n    queryStorage.subject.complete()\n  }\n\n  const clearQueryStorageIfNeeded = <T extends SerializableType, U>(queryStorage: RemeshQueryStorage<T, U>) => {\n    if (queryStorage.refCount !== 0) {\n      return\n    }\n\n    if (queryStorage.downstreamSet.size !== 0) {\n      return\n    }\n\n    clearQueryStorage(queryStorage)\n  }\n\n  const clearStateStorage = <T extends SerializableType, U>(stateStorage: RemeshStateStorage<T, U>) => {\n    const domainStorage = getDomainStorage(stateStorage.State.owner)\n\n    if (!domainStorage.stateMap.has(stateStorage.key)) {\n      return\n    }\n\n    inspectorManager.inspectStateStorage(InspectorType.StateDestroyed, stateStorage)\n    domainStorage.stateMap.delete(stateStorage.key)\n    stateStorage.downstreamSet.clear()\n  }\n\n  const clearStateStorageIfNeeded = <T extends SerializableType, U>(stateStorage: RemeshStateStorage<T, U>) => {\n    if (stateStorage.downstreamSet.size !== 0) {\n      return\n    }\n\n    clearStateStorage(stateStorage)\n  }\n\n  const clearEventStorage = <T, U>(eventStorage: RemeshEventStorage<T, U>) => {\n    const domainStorage = getDomainStorage(eventStorage.Event.owner)\n\n    eventStorage.subject.complete()\n    domainStorage.eventMap.delete(eventStorage.Event)\n  }\n\n  const clearEventStorageIfNeeded = <T, U>(eventStorage: RemeshEventStorage<T, U>) => {\n    if (eventStorage.refCount !== 0) {\n      return\n    }\n\n    clearEventStorage(eventStorage)\n  }\n\n  const clearCommand$Storage = <T>(command$Storage: RemeshCommand$Storage<T>) => {\n    const domainStorage = getDomainStorage(command$Storage.Command$.owner)\n\n    command$Storage.subject.complete()\n    command$Storage.subscription?.unsubscribe()\n    command$Storage.subscription = undefined\n\n    domainStorage.command$Map.delete(command$Storage.Command$)\n  }\n\n  const clearDomainStorage = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainStorage: RemeshDomainStorage<T, Arg>,\n  ) => {\n    inspectorManager.inspectDomainStorage(InspectorType.DomainDestroyed, domainStorage)\n\n    clearSubscriptionSet(domainStorage.domainSubscriptionSet)\n    clearSubscriptionSet(domainStorage.upstreamSubscriptionSet)\n\n    for (const eventStorage of domainStorage.eventMap.values()) {\n      clearEventStorage(eventStorage)\n    }\n\n    for (const queryStorage of domainStorage.queryMap.values()) {\n      clearQueryStorage(queryStorage)\n    }\n\n    for (const stateStorage of domainStorage.stateMap.values()) {\n      clearStateStorage(stateStorage)\n    }\n\n    for (const command$Storage of domainStorage.command$Map.values()) {\n      clearCommand$Storage(command$Storage)\n    }\n\n    domainStorage.upstreamSubscriptionSet.clear()\n    domainStorage.domainSubscriptionSet.clear()\n    domainStorage.downstreamSet.clear()\n    domainStorage.stateMap.clear()\n    domainStorage.queryMap.clear()\n    domainStorage.eventMap.clear()\n\n    domainStorage.running = false\n\n    domainStorageMap.delete(domainStorage.key)\n\n    for (const upstreamDomainStorage of domainStorage.upstreamSet) {\n      upstreamDomainStorage.downstreamSet.delete(domainStorage)\n      clearDomainStorageIfNeeded(upstreamDomainStorage)\n    }\n  }\n\n  const clearDomainStorageIfNeeded = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainStorage: RemeshDomainStorage<T, Arg>,\n  ) => {\n    if (domainStorage.refCount !== 0) {\n      return\n    }\n\n    if (domainStorage.downstreamSet.size !== 0) {\n      return\n    }\n\n    if (domainStorage.domainSubscriptionSet.size !== 0) {\n      return\n    }\n\n    clearDomainStorage(domainStorage)\n  }\n\n  const getCurrentState = <T extends SerializableType, U>(stateItem: RemeshStateItem<T, U>): U => {\n    const stateStorage = getStateStorage(stateItem)\n\n    return getStateFromStorage(stateStorage)\n  }\n\n  const getCurrentQueryValue = <T extends SerializableType, U>(queryPayload: RemeshQueryPayload<T, U>): U => {\n    const queryStorage = getQueryStorage(queryPayload)\n    const currentValue = queryStorage.currentValue\n\n    if (currentValue === RemeshValuePlaceholder) {\n      throw new Error(`Query ${queryStorage.key} is not ready yet.`)\n    }\n\n    return currentValue\n  }\n\n  const unwrappedQueryWeakMap = new WeakMap<RemeshQueryStorage<any, any>, RemeshQueryPayload<any, any>>()\n\n  const getUnwrappedQueryPayload = <T extends SerializableType, U>(\n    queryPayload: RemeshQueryPayload<T, Promise<U>>,\n  ): RemeshQueryPayload<void, PromiseData<U>> => {\n    const queryStorage = getQueryStorage(queryPayload)\n\n    if (unwrappedQueryWeakMap.has(queryStorage)) {\n      return unwrappedQueryWeakMap.get(queryStorage)!\n    }\n\n    const domainStorage = getDomainStorage(queryPayload.Query.owner)\n    const domainContext = domainStorage.domainContext\n\n    const promise = remeshInjectedContext.get(queryPayload)\n    const promiseData = getPromiseData(promise)\n\n    const UnwrappedState = domainContext.state({\n      name: `${queryPayload.Query.queryName}.UnwrappedState`,\n      inspectable: false,\n      default: promiseData,\n    })\n\n    const UnwrappedQuery = domainContext.query({\n      name: `${queryPayload.Query.queryName}.UnwrappedQuery`,\n      inspectable: false,\n      impl: ({ get }) => {\n        const unwrappedState = get(UnwrappedState())\n        return unwrappedState\n      },\n    })\n\n    const updateUnwrappedState = domainContext.command({\n      name: `${queryPayload.Query.queryName}.updateUnwrappedState`,\n      inspectable: false,\n      impl: (_, newState: PromiseData<U>) => {\n        return UnwrappedState().new(newState)\n      },\n    })\n\n    domainContext.command$({\n      name: `${queryPayload.Query.queryName}.UnwrappedCommand$`,\n      inspectable: false,\n      impl: ({ fromQuery, get }) => {\n        return fromQuery(queryPayload).pipe(\n          startWith(get(queryPayload)),\n          switchMap(promiseToObservable),\n          map(updateUnwrappedState),\n        )\n      },\n    })\n\n    const unwrappedQueryPayload = UnwrappedQuery()\n\n    unwrappedQueryWeakMap.set(queryStorage, unwrappedQueryPayload)\n\n    return unwrappedQueryPayload\n  }\n\n  const remeshInjectedContext: RemeshInjectedContext = {\n    get: (input) => {\n      if (input.type === 'RemeshStateItem') {\n        return getCurrentState(input)\n      }\n\n      if (input.type === 'RemeshQueryPayload') {\n        return getCurrentQueryValue(input)\n      }\n\n      throw new Error(`Unexpected input in ctx.get(..): ${input}`)\n    },\n    /**\n     * unwrap() should not use arrow functions\n     * because arrow functions do not have access to `this` keyword\n     * and we need to use the difference get() methods in query-context\n     */\n    unwrap(input) {\n      const unwrappedQueryPayload = getUnwrappedQueryPayload(input)\n      const result = this.get(unwrappedQueryPayload)\n\n      return result\n    },\n    fromEvent: (Event) => {\n      const eventStorage = getEventStorage(Event)\n      return eventStorage.observable\n    },\n    fromQuery: (queryPayload) => {\n      const queryStorage = getQueryStorage(queryPayload)\n      return queryStorage.observable\n    },\n  }\n\n  const updateQueryStorage = <T extends SerializableType, U>(queryStorage: RemeshQueryStorage<T, U>) => {\n    if (queryStorage.schedulerSubject) {\n      if (queryStorage.currentValue !== RemeshValuePlaceholder) {\n        queryStorage.schedulerSubject.next(queryStorage.currentValue)\n      } else {\n        throw new Error(`Query ${queryStorage.key} is not ready yet.`)\n      }\n    } else {\n      updateQueryStorageImmediately(queryStorage)\n    }\n  }\n\n  const updateQueryStorageImmediately = <T extends SerializableType, U>(queryStorage: RemeshQueryStorage<T, U>) => {\n    const { Query } = queryStorage\n\n    for (const upstream of queryStorage.upstreamSet) {\n      upstream.downstreamSet.delete(queryStorage)\n      if (upstream.downstreamSet.size === 0) {\n        pendingStorageSet.add(upstream)\n      }\n    }\n\n    const upstreamSet: RemeshQueryStorage<T, U>['upstreamSet'] = new Set()\n\n    queryStorage.upstreamSet = upstreamSet\n\n    const queryContext: RemeshQueryContext = {\n      get: (input) => {\n        if (queryStorage.upstreamSet !== upstreamSet) {\n          return remeshInjectedContext.get(input)\n        }\n\n        if (input.type === 'RemeshStateItem') {\n          const upstreamStateStorage = getStateStorage(input)\n\n          queryStorage.upstreamSet.add(upstreamStateStorage)\n          upstreamStateStorage.downstreamSet.add(queryStorage)\n\n          return remeshInjectedContext.get(input)\n        }\n\n        if (input.type === 'RemeshQueryPayload') {\n          const upstreamQueryStorage = getQueryStorage(input)\n\n          queryStorage.upstreamSet.add(upstreamQueryStorage)\n          upstreamQueryStorage.downstreamSet.add(queryStorage)\n\n          return remeshInjectedContext.get(input)\n        }\n\n        return remeshInjectedContext.get(input)\n      },\n      get unwrap() {\n        return remeshInjectedContext.unwrap.bind(queryContext)\n      },\n    }\n\n    prepareQuery(Query, queryContext, queryStorage.arg)\n\n    const newValue = Query.impl(queryContext, queryStorage.arg)\n\n    if (queryStorage.currentValue !== RemeshValuePlaceholder) {\n      const isEqual = Query.compare(queryStorage.currentValue, newValue)\n\n      if (isEqual) {\n        return\n      }\n    }\n\n    queryStorage.currentValue = newValue\n\n    if (newValue instanceof Promise) {\n      getPromiseData(newValue)\n    }\n\n    dirtySet.add(queryStorage)\n\n    inspectorManager.inspectQueryStorage(InspectorType.QueryUpdated, queryStorage)\n\n    /**\n     * updateQueryStorage may update upstream.downstreamSet\n     * so it should be converted to an array for avoiding infinite loop\n     */\n    for (const downstream of [...queryStorage.downstreamSet]) {\n      updateQueryStorage(downstream)\n    }\n  }\n\n  const clearPendingStorageSetIfNeeded = () => {\n    if (pendingStorageSet.size === 0) {\n      return\n    }\n\n    const storageList = [...pendingStorageSet]\n\n    pendingStorageSet.clear()\n\n    for (const storage of storageList) {\n      if (storage.type === 'RemeshDomainStorage') {\n        clearDomainStorageIfNeeded(storage)\n      } else if (storage.type === 'RemeshEventStorage') {\n        clearEventStorageIfNeeded(storage)\n      } else if (storage.type === 'RemeshQueryStorage') {\n        clearQueryStorageIfNeeded(storage)\n      } else if (storage.type === 'RemeshStateStorage') {\n        clearStateStorageIfNeeded(storage)\n      }\n    }\n\n    clearPendingStorageSetIfNeeded()\n  }\n\n  const clearDirtySetIfNeeded = () => {\n    if (dirtySet.size === 0) {\n      return\n    }\n\n    const queryStorageList = [...dirtySet]\n\n    dirtySet.clear()\n\n    for (const queryStorage of queryStorageList) {\n      if (!dirtySet.has(queryStorage)) {\n        queryStorage.subject.next(queryStorage.currentValue)\n      }\n    }\n\n    /**\n     * recursively consuming dirty set unit it become empty.\n     */\n    clearDirtySetIfNeeded()\n  }\n\n  const commit = () => {\n    clearDirtySetIfNeeded()\n  }\n\n  const handleStatePayload = <T extends SerializableType, U>(statePayload: RemeshStatePayload<T, U>) => {\n    const stateStorage = getStateStorage(statePayload.stateItem)\n\n    if (stateStorage.currentState !== RemeshValuePlaceholder) {\n      const isEqual = statePayload.stateItem.State.compare(stateStorage.currentState, statePayload.newState)\n\n      if (isEqual) {\n        return\n      }\n    }\n\n    stateStorage.currentState = statePayload.newState\n\n    inspectorManager.inspectStateStorage(InspectorType.StateUpdated, stateStorage)\n\n    /**\n     * updateQueryStorage may update upstream.downstreamSet\n     * so it should be converted to an array for avoiding infinite loop\n     */\n    for (const downstream of [...stateStorage.downstreamSet]) {\n      updateQueryStorage(downstream)\n    }\n  }\n\n  const handleEventPayload = <T, U = T>(eventPayload: RemeshEventPayload<T, U>) => {\n    const { Event, arg } = eventPayload\n    const eventStorage = getEventStorage(Event)\n\n    inspectorManager.inspectEventEmitted(InspectorType.EventEmitted, eventPayload)\n\n    if (Event.impl) {\n      const eventContext = {\n        get: remeshInjectedContext.get,\n        get unwrap() {\n          return remeshInjectedContext.unwrap.bind(eventContext)\n        },\n      }\n      const data = Event.impl(eventContext, arg)\n      eventStorage.subject.next(data)\n    } else {\n      eventStorage.subject.next(arg as unknown as U)\n    }\n  }\n\n  const handleCommandPayload = <T>(commandPayload: RemeshCommandPayload<T>) => {\n    inspectorManager.inspectCommandReceived(InspectorType.CommandReceived, commandPayload)\n\n    const { Command, arg } = commandPayload\n    const commandContext: RemeshCommandContext = {\n      get: remeshInjectedContext.get,\n      get unwrap() {\n        return remeshInjectedContext.unwrap.bind(commandContext)\n      },\n    }\n\n    const commandOutput = Command.impl(commandContext, arg)\n    handleCommandOutput(commandOutput)\n  }\n\n  const handleSubscription = (subscriptionSet: Set<Subscription>, subscription: Subscription) => {\n    subscriptionSet.add(subscription)\n\n    subscription.add(() => {\n      subscriptionSet.delete(subscription)\n    })\n  }\n\n  const initCommand$IfNeeded = <T>(Command$: RemeshCommand$<T>) => {\n    const command$Storage = getCommand$Storage(Command$)\n\n    if (command$Storage.subscription) {\n      return\n    }\n\n    const command$Context: RemeshCommand$Context = {\n      get: remeshInjectedContext.get,\n      get unwrap() {\n        return remeshInjectedContext.unwrap.bind(command$Context)\n      },\n      fromEvent: remeshInjectedContext.fromEvent,\n      fromQuery: remeshInjectedContext.fromQuery,\n    }\n\n    const command$ = Command$.impl(command$Context, command$Storage.observable)\n\n    const subscription = command$.subscribe((commandOutput) => {\n      handleCommandOutput(commandOutput)\n      commit()\n    })\n\n    command$Storage.subscription = subscription\n  }\n\n  const handleCommandOutput = (commandOutput: RemeshCommandOutput) => {\n    if (commandOutput === null) {\n      return\n    }\n\n    if (Array.isArray(commandOutput)) {\n      for (const item of commandOutput) {\n        handleCommandOutput(item)\n      }\n      return\n    }\n\n    if (commandOutput.type === 'RemeshCommandPayload') {\n      handleCommandPayload(commandOutput)\n      return\n    } else if (commandOutput.type === 'RemeshEventPayload') {\n      handleEventPayload(commandOutput)\n      return\n    } else if (commandOutput.type === 'RemeshStateSetterPayload') {\n      handleStatePayload(commandOutput)\n      return\n    } else if (commandOutput.type === 'RemeshCommand$Payload') {\n      handleCommand$Payload(commandOutput)\n      return\n    }\n\n    throw new Error(`Unknown command output of ${commandOutput}`)\n  }\n\n  const handleCommand$Payload = <T>(command$Payload: RemeshCommand$Payload<T>) => {\n    inspectorManager.inspectCommand$Received(InspectorType.Command$Received, command$Payload)\n\n    const { Command$, arg } = command$Payload\n    const command$Storage = getCommand$Storage(Command$)\n\n    initCommand$IfNeeded(Command$)\n    command$Storage.subject.next(arg)\n  }\n\n  const addDomainSubscription = (domainStorage: RemeshDomainStorage<any, any>, domainSubscription: Subscription) => {\n    handleSubscription(domainStorage.domainSubscriptionSet, domainSubscription)\n\n    domainSubscription.add(() => {\n      pendingStorageSet.add(domainStorage)\n      clearPendingStorageSetIfNeeded()\n    })\n  }\n\n  const subscribeQuery = <T extends SerializableType, U>(\n    queryPayload: RemeshQueryPayload<T, U>,\n    subscriber: ((data: U) => unknown) | Partial<Observer<U>>,\n  ): Subscription => {\n    const queryStorage = getQueryStorage(queryPayload)\n    const subscription =\n      typeof subscriber === 'function'\n        ? queryStorage.observable.subscribe(subscriber)\n        : queryStorage.observable.subscribe(subscriber)\n\n    return subscription\n  }\n\n  const subscribeEvent = <T, U = T>(Event: RemeshEvent<T, U>, subscriber: (event: U) => unknown) => {\n    const eventStorage = getEventStorage(Event)\n    const subscription = eventStorage.observable.subscribe(subscriber)\n\n    return subscription\n  }\n\n  const getBindingCommand = <T extends RemeshDomainDefinition>(domain: T) => {\n    const command = {}\n\n    for (const key in domain.command) {\n      const Command = domain.command[key]\n      command[key] = (arg: any) => sendCommand(Command(arg))\n    }\n\n    return command as BindingCommand<T['command']>\n  }\n\n  const getDomain = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainPayload: RemeshDomainPayload<T, Arg>,\n  ): BindingDomainOutput<T> => {\n    const domainStorage = getDomainStorage(domainPayload)\n\n    if (domainStorage.domainOutput) {\n      return domainStorage.domainOutput\n    }\n\n    const domain = domainStorage.domain\n    const command = getBindingCommand(domain)\n\n    const domainOutput = {\n      ...domain,\n      command,\n    }\n\n    domainStorage.domainOutput = domainOutput\n\n    return domainOutput\n  }\n\n  const initCommand$Set = (command$Set: RemeshDomainStorage<any, any>['command$Set']) => {\n    for (const Command$ of command$Set) {\n      initCommand$IfNeeded(Command$)\n    }\n  }\n\n  const runDomainStorageIfNeeded = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainStorage: RemeshDomainStorage<T, Arg>,\n  ) => {\n    if (domainStorage.running) {\n      return\n    }\n\n    domainStorage.running = true\n\n    for (const upstreamDomainStorage of domainStorage.upstreamSet) {\n      const upstreamDomainSubscription = subscribeDomain(upstreamDomainStorage.domainPayload)\n      handleSubscription(domainStorage.upstreamSubscriptionSet, upstreamDomainSubscription)\n    }\n\n    initCommand$Set(domainStorage.command$Set)\n  }\n\n  const subscribeDomain = <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n    domainPayload: RemeshDomainPayload<T, Arg>,\n  ): Subscription => {\n    const domainStorage = getDomainStorage(domainPayload)\n    const domainSubscription = new Subscription()\n\n    addDomainSubscription(domainStorage, domainSubscription)\n    runDomainStorageIfNeeded(domainStorage)\n\n    return domainSubscription\n  }\n\n  const destroy = () => {\n    inspectorManager.destroyInspectors()\n\n    for (const domainStorage of domainStorageMap.values()) {\n      clearDomainStorage(domainStorage)\n    }\n    domainStorageMap.clear()\n    dirtySet.clear()\n  }\n\n  const emitEvent = <T, U>(eventPayload: RemeshEventPayload<T, U>) => {\n    handleEventPayload(eventPayload)\n  }\n\n  const sendCommand = <T>(input: RemeshCommandPayload<T> | RemeshCommand$Payload<T>) => {\n    if (input.type === 'RemeshCommandPayload') {\n      handleCommandPayload(input)\n      commit()\n    } else if (input.type === 'RemeshCommand$Payload') {\n      handleCommand$Payload(input)\n    }\n  }\n\n  const unwrap = <T extends SerializableType, U>(input: RemeshQueryPayload<T, Promise<U>>): PromiseData<U> => {\n    return remeshInjectedContext.unwrap(input)\n  }\n\n  return {\n    name: config.name,\n    getDomain,\n    query: getCurrentQueryValue,\n    unwrap,\n    getUnwrappedQueryPayload,\n    emitEvent,\n    sendCommand,\n    destroy,\n    subscribeQuery,\n    subscribeEvent,\n    subscribeDomain,\n    getKey: getStorageKey,\n  }\n}\n\nconst clearSubscriptionSet = (subscriptionSet: Set<Subscription>) => {\n  for (const subscription of subscriptionSet) {\n    subscription.unsubscribe()\n  }\n}\n","import {\n  RemeshDomain,\n  RemeshExtern,\n  RemeshState,\n  RemeshQuery,\n  RemeshCommand,\n  RemeshCommand$,\n  RemeshCommandAsync,\n} from './remesh'\n\nimport { RemeshStore } from './store'\n\nexport * from './remesh'\nexport * from './store'\nexport * from './inspector'\nexport * from './promise'\n\nexport const Remesh = {\n  domain: RemeshDomain,\n  extern: RemeshExtern,\n  store: RemeshStore,\n  state: RemeshState,\n  query: RemeshQuery,\n  command: RemeshCommand,\n  command$: RemeshCommand$,\n  commandAsync: RemeshCommandAsync,\n}\n","import React, { useEffect, useRef, useContext, createContext, ReactNode, useCallback, useMemo } from 'react'\n\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  RemeshDomainDefinition,\n  RemeshQueryPayload,\n  RemeshEvent,\n  RemeshDomainPayload,\n  RemeshStore,\n  PromiseData,\n  getPromiseData,\n  SerializableType,\n} from 'remesh'\n\nexport type RemeshReactContext = {\n  remeshStore: RemeshStore\n}\n\nexport const RemeshReactContext = createContext<RemeshReactContext | null>(null)\n\nexport const useRemeshReactContext = () => {\n  const context = useContext(RemeshReactContext)\n\n  if (context === null) {\n    throw new Error(`You may forgot to add <RemeshRoot />`)\n  }\n\n  return context\n}\n\nexport const useRemeshStore = (): RemeshStore => {\n  const context = useRemeshReactContext()\n  return context.remeshStore\n}\n\nexport type RemeshRootProps = {\n  children: ReactNode\n  store: RemeshStore\n}\n\nexport const RemeshRoot = (props: RemeshRootProps) => {\n  const contextValue: RemeshReactContext = useMemo(() => {\n    return {\n      remeshStore: props.store,\n    }\n  }, [props.store])\n\n  return <RemeshReactContext.Provider value={contextValue}>{props.children}</RemeshReactContext.Provider>\n}\n\nexport const useRemeshQuery = function <T extends SerializableType, U>(queryPayload: RemeshQueryPayload<T, U>): U {\n  const store = useRemeshStore()\n\n  const triggerRef = useRef<(() => void) | null>(null)\n\n  const subscribe = useCallback((triggerUpdate: () => void) => {\n    triggerRef.current = triggerUpdate\n    return () => {\n      triggerRef.current = null\n    }\n  }, [])\n\n  const getSnapshot = useCallback(() => {\n    const snapshot = store.query(queryPayload)\n    return snapshot\n  }, [store, queryPayload])\n\n  const state = useSyncExternalStore(subscribe, getSnapshot)\n\n  const subscriptionRef = useRef<{ unsubscribe: () => void } | null>(null)\n\n  const queryKey = store.getKey(queryPayload)\n\n  useEffect(() => {\n    return () => {\n      subscriptionRef.current?.unsubscribe()\n      subscriptionRef.current = null\n    }\n  }, [store, queryKey])\n\n  useEffect(() => {\n    if (subscriptionRef.current !== null) {\n      return\n    }\n    subscriptionRef.current = store.subscribeQuery(queryPayload, () => {\n      triggerRef.current?.()\n    })\n  }, [store, queryPayload])\n\n  return state\n}\n\nexport const useRemeshAsyncQuery = function <T extends SerializableType, U>(\n  queryPayload: RemeshQueryPayload<T, Promise<U>>,\n): PromiseData<U> {\n  const store = useRemeshStore()\n  const unwrappedQueryPayload = store.getUnwrappedQueryPayload(queryPayload)\n  const data = useRemeshQuery(unwrappedQueryPayload)\n\n  return data\n}\n\nexport const useRemeshSuspenseQuery = function <T extends SerializableType, U>(\n  queryPayload: RemeshQueryPayload<T, Promise<U>>,\n): U {\n  const promise = useRemeshQuery(queryPayload)\n  const promiseData = getPromiseData(promise)\n\n  if (promiseData.type === 'pending') {\n    throw promise\n  }\n\n  if (promiseData.type === 'rejected') {\n    throw promiseData.error\n  }\n\n  return promiseData.value\n}\n\nexport const useRemeshEvent = function <T, U = T>(Event: RemeshEvent<T, U>, callback: (data: U) => unknown) {\n  const store = useRemeshStore()\n  const callbackRef = useRef(callback)\n\n  useEffect(() => {\n    callbackRef.current = callback\n  })\n\n  useEffect(() => {\n    const subscription = store.subscribeEvent(Event, (data) => {\n      callbackRef.current(data)\n    })\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [Event, store])\n}\n\nexport const useRemeshEmit = function () {\n  const store = useRemeshStore()\n\n  return store.emitEvent\n}\n\nexport const useRemeshDomain = function <T extends RemeshDomainDefinition, Arg extends SerializableType>(\n  domainPayload: RemeshDomainPayload<T, Arg>,\n) {\n  const store = useRemeshStore()\n  const subscriptionRef = useRef<{ unsubscribe: () => void } | null>(null)\n  const domain = store.getDomain(domainPayload)\n  const domainKey = store.getKey(domainPayload)\n\n  useEffect(() => {\n    return () => {\n      subscriptionRef.current?.unsubscribe()\n      subscriptionRef.current = null\n    }\n  }, [store, domainKey])\n\n  useEffect(() => {\n    if (subscriptionRef.current !== null) {\n      return\n    }\n    subscriptionRef.current = store.subscribeDomain(domainPayload)\n  }, [store, domainPayload])\n\n  return domain\n}\n","export const formatTime = (time: Date) => {\r\n  const hours = time.getHours().toString().padStart(2, '0')\r\n  const minutes = time.getMinutes().toString().padStart(2, '0')\r\n  const seconds = time.getSeconds().toString().padStart(2, '0')\r\n  const milliseconds = time.getMilliseconds().toString().padStart(3, '0')\r\n\r\n  return `${hours}:${minutes}:${seconds}.${milliseconds}`\r\n}\r\n\r\nexport const formatNow = () => {\r\n  const time = new Date()\r\n\r\n  return formatTime(time)\r\n}\r\n\r\nexport type RemeshDebugSource = 'state' | 'query' | 'domain' | 'event' | 'command' | 'command$'\r\n\r\nexport type RemeshDebugOptions = {\r\n  include?: RemeshDebugSource[]\r\n  exclude?: RemeshDebugSource[]\r\n}\r\n\r\nexport const RemeshDebuggerHelper = (options?: RemeshDebugOptions) => {\r\n  const config = {\r\n    include: ['state', 'domain', 'event', 'command', 'command$'],\r\n    ...options,\r\n  }\r\n\r\n  const onActive = (source: RemeshDebugSource, fn: () => unknown) => {\r\n    if (config.exclude?.includes(source)) {\r\n      return\r\n    }\r\n\r\n    if (config.include) {\r\n      if (config.include.includes(source)) {\r\n        fn()\r\n      }\r\n    } else {\r\n      fn()\r\n    }\r\n  }\r\n\r\n  return {\r\n    onActive,\r\n  }\r\n}\r\n","import { Remesh, RemeshDomainPayload, RemeshInspectorDomain, RemeshStoreOptions, SerializableType } from 'remesh'\nimport { RemeshDebuggerHelper, RemeshDebugOptions } from 'remesh-debugger-helper'\n\nimport type { Config as _Config } from '@redux-devtools/extension'\nimport type { Action } from 'redux'\n\nconst getReduxDevtools = () => {\n  if (typeof window !== 'undefined') {\n    return window.__REDUX_DEVTOOLS_EXTENSION__\n  }\n}\n\nexport type RemeshReduxDevtoolsOptions = RemeshDebugOptions\n\nexport const RemeshReduxDevtools = (options?: RemeshReduxDevtoolsOptions) => {\n  const reduxDevtools = getReduxDevtools()\n\n  if (!reduxDevtools) {\n    return\n  }\n\n  return (storeOptions?: RemeshStoreOptions) => {\n    const helper = RemeshDebuggerHelper(options)\n\n    const devtools = reduxDevtools.connect({\n      name: storeOptions?.name,\n      features: {\n        pause: false, // start/pause recording of dispatched actions\n        lock: false, // lock/unlock dispatching actions and side effects\n        persist: false, // persist states on page reloading\n        export: false, // export history of actions in a file\n        import: false, // import history of actions from a file\n        jump: false, // jump back and forth (time traveling)\n        skip: false, // skip (cancel) actions\n        reorder: false, // drag and drop actions in the history list\n        dispatch: false, // dispatch custom actions or action creators\n        test: false, // generate tests for the selected actions\n      },\n    })\n\n    const send = (_type: string, action: Action<unknown>) => {\n      devtools.send(action, null)\n    }\n\n    const store = Remesh.store({\n      name: `RemeshReduxDevtools(${storeOptions?.name ?? ''})`,\n    })\n\n    const inspectorDomain = store.getDomain(RemeshInspectorDomain())\n\n    const getOwnerInfo = <T, U extends SerializableType>(owner: RemeshDomainPayload<T, U>) => {\n      const ownerInfo = {\n        domainId: owner.Domain.domainId,\n        domainName: owner.Domain.domainName,\n      }\n\n      if (owner.arg !== undefined) {\n        return {\n          ...ownerInfo,\n          domainArg: owner.arg,\n        }\n      }\n\n      return ownerInfo\n    }\n\n    helper.onActive('domain', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshDomainStorageEvent, (event) => {\n        const Domain = event.storage.Domain\n        const info = {\n          type: `${event.type}::${Domain.domainName}`,\n          domainId: Domain.domainId,\n          domainName: Domain.domainName,\n        }\n\n        if (event.storage.arg !== undefined) {\n          send(info.type, {\n            ...info,\n            domainArg: event.storage.arg,\n          })\n        } else {\n          send(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('state', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshStateStorageEvent, (event) => {\n        const State = event.storage.State\n        const info = {\n          type: `${event.type}::${State.stateName}`,\n          owner: getOwnerInfo(State.owner),\n          stateId: State.stateId,\n          stateName: State.stateName,\n          stateValue: event.storage.currentState,\n        }\n\n        if (event.storage.arg !== undefined) {\n          send(info.type, {\n            ...info,\n            stateArg: event.storage.arg,\n          })\n        } else {\n          send(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('query', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshQueryStorageEvent, (event) => {\n        const Query = event.storage.Query\n        const info = {\n          type: `${event.type}::${Query.queryName}`,\n          owner: getOwnerInfo(Query.owner),\n          queryId: Query.queryId,\n          queryName: Query.queryName,\n        }\n\n        if (event.storage.arg !== undefined) {\n          send(info.type, {\n            ...info,\n            queryArg: event.storage.arg,\n          })\n        } else {\n          send(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('command', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshCommandReceivedEvent, (event) => {\n        const Command = event.payload.Command\n        const info = {\n          type: `${event.type}::${Command.commandName}`,\n          owner: getOwnerInfo(Command.owner),\n          commandId: Command.commandId,\n          commandName: Command.commandName,\n        }\n\n        if (event.payload.arg !== undefined) {\n          send(info.type, {\n            ...info,\n            commandArg: event.payload.arg,\n          })\n        } else {\n          send(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('command$', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshCommand$ReceivedEvent, (event) => {\n        const Command$ = event.payload.Command$\n        const info = {\n          type: `${event.type}::${Command$.command$Name}`,\n          owner: getOwnerInfo(Command$.owner),\n          command$Id: Command$.command$Id,\n          command$Name: Command$.command$Name,\n        }\n\n        if (event.payload.arg !== undefined) {\n          send(info.type, {\n            ...info,\n            command$Arg: event.payload.arg,\n          })\n        } else {\n          send(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('event', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshEventEmittedEvent, (event) => {\n        const Event = event.payload.Event\n\n        const info = {\n          type: `${event.type}::${Event.eventName}`,\n          owner: getOwnerInfo(Event.owner),\n          eventId: Event.eventId,\n          eventName: Event.eventName,\n        }\n\n        if (event.payload.arg !== undefined) {\n          send(info.type, {\n            ...info,\n            eventArg: event.payload.arg,\n          })\n        } else {\n          send(info.type, info)\n        }\n      })\n    })\n\n    return store\n  }\n}\n","import { Remesh, RemeshDomainPayload, RemeshInspectorDomain, RemeshStoreInspector, SerializableType } from 'remesh'\n\nimport { RemeshDebugOptions, RemeshDebuggerHelper, formatNow } from 'remesh-debugger-helper'\n\nexport type RemeshLoggerOptions = RemeshDebugOptions & {\n  collapsed?: boolean\n}\n\nexport const RemeshLogger = (options?: RemeshLoggerOptions): RemeshStoreInspector => {\n  return (storeOptions) => {\n    const config = {\n      collapsed: true,\n      ...options,\n    }\n\n    const helper = RemeshDebuggerHelper(config)\n\n    const log = (type: string, info: object) => {\n      if (config.collapsed) {\n        const parts = type.split('::')\n        console.groupCollapsed(\n          `%c${parts[0]}%c::%c${parts[1]}%c::%c${parts[2]}%c @ ${formatNow()}`,\n          'color:#03A9F4; font-weight: bold',\n          'color:#9E9E9E; font-weight: bold',\n          'color:#4CAF50; font-weight: bold',\n          'color:#9E9E9E; font-weight: bold',\n          'color:#AA07DE; font-weight: bold',\n          `color:#9E9E9E; font-weight: lighter`,\n        )\n      }\n\n      console.log(info)\n\n      if (config.collapsed) {\n        console.groupEnd()\n      }\n    }\n\n    const store = Remesh.store({\n      ...storeOptions,\n      name: `RemeshLogger(${storeOptions?.name ?? ''})`,\n    })\n\n    const inspectorDomain = store.getDomain(RemeshInspectorDomain())\n\n    const getOwnerInfo = <T, U extends SerializableType>(owner: RemeshDomainPayload<T, U>) => {\n      const ownerInfo = {\n        domainId: owner.Domain.domainId,\n        domainName: owner.Domain.domainName,\n      }\n\n      if (owner.arg !== undefined) {\n        return {\n          ...ownerInfo,\n          domainArg: owner.arg,\n        }\n      }\n\n      return ownerInfo\n    }\n\n    helper.onActive('domain', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshDomainStorageEvent, (event) => {\n        const Domain = event.storage.Domain\n        const info = {\n          type: `${event.type}::${Domain.domainName}`,\n          domainId: Domain.domainId,\n          domainName: Domain.domainName,\n        }\n\n        if (event.storage.arg !== undefined) {\n          log(info.type, {\n            ...info,\n            domainArg: event.storage.arg,\n          })\n        } else {\n          log(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('state', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshStateStorageEvent, (event) => {\n        const State = event.storage.State\n        const info = {\n          type: `${event.type}::${State.stateName}`,\n          owner: getOwnerInfo(State.owner),\n          stateId: State.stateId,\n          stateName: State.stateName,\n          stateValue: event.storage.currentState,\n        }\n\n        if (event.storage.arg !== undefined) {\n          log(info.type, {\n            ...info,\n            stateArg: event.storage.arg,\n          })\n        } else {\n          log(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('query', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshQueryStorageEvent, (event) => {\n        const Query = event.storage.Query\n        const info = {\n          type: `${event.type}::${Query.queryName}`,\n          owner: getOwnerInfo(Query.owner),\n          queryId: Query.queryId,\n          queryName: Query.queryName,\n          queryValue: event.storage.currentValue,\n        }\n\n        if (event.storage.arg !== undefined) {\n          log(info.type, {\n            ...info,\n            queryArg: event.storage.arg,\n          })\n        } else {\n          log(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('command', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshCommandReceivedEvent, (event) => {\n        const Command = event.payload.Command\n        const info = {\n          type: `${event.type}::${Command.commandName}`,\n          owner: getOwnerInfo(Command.owner),\n          commandId: Command.commandId,\n          commandName: Command.commandName,\n        }\n\n        if (event.payload.arg !== undefined) {\n          log(info.type, {\n            ...info,\n            commandArg: event.payload.arg,\n          })\n        } else {\n          log(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('command$', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshCommand$ReceivedEvent, (event) => {\n        const Command$ = event.payload.Command$\n        const info = {\n          type: `${event.type}::${Command$.command$Name}`,\n          owner: getOwnerInfo(Command$.owner),\n          command$Id: Command$.command$Id,\n          command$Name: Command$.command$Name,\n        }\n\n        if (event.payload.arg !== undefined) {\n          log(info.type, {\n            ...info,\n            command$Arg: event.payload.arg,\n          })\n        } else {\n          log(info.type, info)\n        }\n      })\n    })\n\n    helper.onActive('event', () => {\n      store.subscribeEvent(inspectorDomain.event.RemeshEventEmittedEvent, (event) => {\n        const Event = event.payload.Event\n\n        const info = {\n          type: `${event.type}::${Event.eventName}`,\n          owner: getOwnerInfo(Event.owner),\n          eventId: Event.eventId,\n          eventName: Event.eventName,\n        }\n\n        if (event.payload.arg !== undefined) {\n          log(info.type, {\n            ...info,\n            eventArg: event.payload.arg,\n          })\n        } else {\n          log(info.type, info)\n        }\n      })\n    })\n\n    return store\n  }\n}\n"],"names":["shallowEqual","createContext","useContext","useMemo","useRef","useCallback","useSyncExternalStore","useEffect"],"mappings":"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"}